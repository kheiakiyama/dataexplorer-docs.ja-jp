---
title: エクステント (data シャード)-Azure データエクスプローラー
description: この記事では、Azure データエクスプローラーのエクステント (data シャード) について説明します。
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/13/2020
ms.openlocfilehash: c1ed0de6f638828abe120caffcb5e14517f09a02
ms.sourcegitcommit: 898f67b83ae8cf55e93ce172a6fd3473b7c1c094
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/21/2020
ms.locfileid: "92342741"
---
# <a name="extents-data-shards"></a>エクステント (データシャード)

## <a name="overview"></a>概要

Kusto は、膨大な数のレコード (行) と大量のデータを含むテーブルをサポートするように構築されています。 このような大きなテーブルを処理するために、各テーブルのデータは、 **データシャード** または **エクステント** と呼ばれる小さな "タブレット" に分割されます (2 つの用語は同義です)。 すべてのテーブルのエクステントの和集合は、テーブルのデータを保持します。 個々のエクステントは1つのノードの容量よりも小さく保持され、エクステントはクラスターのノードに分散され、スケールアウトを実現します。

エクステントは、ミニテーブルの一種に似ています。 これには、データ、メタデータ、およびそのデータに関連付けられているオプションのタグなどの情報が含まれます。 さらに、この範囲には通常、Kusto データを効率的に照会できるようにする情報が保持されます。
たとえば、範囲内のデータの各列のインデックス、列データがエンコードされている場合はエンコーディングディクショナリなどです。 その結果、テーブルのデータは、テーブルのエクステント内のすべてのデータの和集合になります。

エクステントは不変であり、変更することはできません。 クエリを行ったり、別のノードに再割り当てしたり、テーブルから削除したりすることはできません。 データ変更は、1つまたは複数の新しいエクステントを作成し、古いエクステントを新しいエクステントでトランザクション処理することによって行われます。

エクステントは、物理的に列に配置されているレコードのコレクションを保持します。
この手法は、 **単票形式のストア**と呼ばれます。 これにより、データの効率的なエンコードと圧縮が可能になります。これは、同じ列の異なる値が相互に "似ている" ことが多いためです。 また、クエリで使用される列のみを読み込む必要があるため、大量のデータのクエリをより効率的に行うことができます。 内部的には、エクステント内のデータの各列がセグメントに分割され、セグメントがブロックに分割されます。 この分割はクエリに対して監視されず、Kusto 列の圧縮とインデックス作成を最適化できます。

クエリの効率を維持するために、小さなエクステントはより大きなエクステントにマージされます。
マージは、構成されている [マージポリシー](mergepolicy.md) と [シャーディングポリシー](shardingpolicy.md)に従って、バックグラウンドプロセスとして自動的に実行されます。
エクステントをマージすると、多数のエクステントを追跡するための管理オーバーヘッドが軽減されます。さらに重要なのは、Kusto でインデックスを最適化し、圧縮を向上させることができることです。

エクステントのマージは、エクステントが特定の時点を超えて、サイズなどの特定の制限に達すると停止します。これにより、マージの効率が向上します。

データの [パーティション分割ポリシー](partitioningpolicy.md) がテーブルで定義されている場合、エクステントは作成後に別のバックグラウンドプロセスを実行します (インジェスト後)。 このプロセスでは、ソースエクステントのデータを reingests し、 *同種* のエクステントを作成します。この場合、テーブルの *パーティションキー* である列の値がすべて同じパーティションに属しています。 ポリシーに *ハッシュパーティションキー*が含まれている場合、同じパーティションに属するすべての同種エクステントがクラスター内の同じデータノードに割り当てられます。

> [!NOTE]
> エクステントタグのマージや変更など、エクステントレベルの操作は、既存のエクステントを変更しません。
> 代わりに、既存のソースエクステントに基づいて、これらの操作で新しいエクステントが作成されます。 新しいエクステントは、1つのトランザクションで forefathers を置き換えます。

共通エクステントのライフサイクルは次のとおりです。

1. このエクステントは **インジェスト** 操作によって作成されます。
1. エクステントは他のエクステントとマージされます。 マージされるエクステントが小さい場合、Kusto は、 **再構築**と呼ばれるインジェストプロセスを実際に実行します。 エクステントが特定のサイズに達すると、マージはインデックスに対してのみ実行されます。 ストレージ内のエクステントのデータアーティファクトは変更されません。
1. マージされたエクステント (場合によっては、他のマージされたエクステントへの系列を追跡する場合など) は、保持ポリシーによって最終的に破棄されます。 
   時間 (過去 x 時間/日) に基づいてエクステントが削除されると、マージされた1つの内部の新しいエクステントの作成日が計算で使用されます。

## <a name="extent-creation-time"></a>エクステントの作成時間

各エクステントの重要な情報の1つに、作成時間があります。 この時間は、次の場合に使用されます。

1. 以前に作成された**保有期間**は、前に削除されます。
1. **キャッシュ** -最近作成されたエクステントは [ホットキャッシュ](cachepolicy.md)に保持されます)
1. **サンプリング** -などのクエリ操作を使用する場合、最近のエクステントが優先されます。 `take`

実際には、Kusto はエクステントごとに2つの値 (と) を追跡し `datetime` `MinCreatedOn` `MaxCreatedOn` ます。
初期状態では、2つの値は同じです。 エクステントが他のエクステントとマージされると、新しい値はマージされたエクステントの元の最小値と最大値に従います。

通常、エクステントの作成時間は、エクステント内のデータが取り込まれたされた時間に従って設定されます。 クライアントは必要に応じて、 [インジェストプロパティ](../../ingestion-properties.md)に別の作成時間を指定することで、エクステントの作成時間を上書きすることができます。
上書きは、保持の目的などに便利です。クライアントがデータを再取り込みするときに、遅延が到着したかのように表示したくない場合などです。

## <a name="extent-tagging"></a>エクステントのタグ付け

Kusto は、メタデータの一部として、複数のオプションの *エクステントタグ* をそのエクステントにアタッチすることをサポートしています。 エクステントタグ (または単に *タグ*) は、エクステントに関連付けられている文字列です。 エクステントに関連付けられたタグを表示するには、エクステントの表示コマンドを使用します [。](./show-extents.md) エクステント内のレコードに関連付けられているタグを表示するには、エクステント [-tags ()](../query/extenttagsfunction.md) 関数を使用します。
エクステントタグを使用すると、エクステント内のすべてのデータに共通するプロパティを効率的に記述できます。
たとえば、インジェスト中にエクステントタグを追加し、取り込まれたデータのソースを示し、後でそのタグを使用することができます。 エクステントはデータを記述するため、2つ以上のマージでは、関連付けられているタグもマージされます。 結果として得られるエクステントのタグは、マージされたエクステントのすべてのタグの和集合になります。

Kusto は、値が形式*プレフィックス**サフィックス*を持つすべてのエクステントタグに特別な意味を割り当てます。 *prefix*は次のいずれかになります。

* `drop-by:`
* `ingest-by:`

### <a name="drop-by-extent-tags"></a>' drop: ' エクステントタグ

プレフィックスで始まるタグを `drop-by:` 使用すると、他のどのエクステントをマージするかを制御できます。 特定のタグを持つエクステントは `drop-by:` 結合できますが、他のエクステントとはマージされません。 その後、コマンドを発行して、そのタグに従ってエクステントを削除でき `drop-by:` ます。

次に例を示します。

```kusto
.ingest ... with @'{"tags":"[\"drop-by:2016-02-17\"]"}'

.drop extents <| .show table MyTable extents where tags has "drop-by:2016-02-17" 
```

#### <a name="performance-notes"></a>パフォーマンスに関する注意

* タグを使いすぎないように `drop-by` します。 上記の方法でデータを削除することは、めったに発生しないイベントを想定しています。 レコードレベルのデータを置き換えるのではなく、このようにタグ付けされたデータが大きくなるという事実に依存しています。 レコードごとに異なるタグを指定しようとすると、レコードの数が少なくなると、パフォーマンスに重大な影響を与える可能性があります。
* `drop-by`データを取り込まれたした後、一定期間、タグが不要な場合は、[タグを削除](#drop-by-extent-tags)することをお勧めします。

### <a name="ingest-by-extent-tags"></a>' インジェスト: ' エクステントタグ

プレフィックスで始まるタグは、 `ingest-by:` データが一度だけ取り込まれたされるようにするために使用できます。 **`ingestIfNotExists`** この特定のタグを持つエクステントが既に存在する場合は、データが取り込まれたされないようにするプロパティコマンドを発行でき `ingest-by:` ます。
との両方の `tags` 値 `ingestIfNotExists` は、JSON としてシリアル化された文字列の配列です。

次の例では、データを1回だけ取り込みします。 2番目と3番目のコマンドは何も行いません。

```kusto
.ingest ... with (tags = '["ingest-by:2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]', tags = '["ingest-by:2016-02-17"]')
```

> [!NOTE]
> 通常、取り込みコマンドには、 `ingest-by:` `ingestIfNotExists` 上記の3番目のコマンドで示すように、同じ値に設定されたタグとプロパティの両方が含まれている可能性があります。

#### <a name="performance-notes"></a>パフォーマンスに関する注意

* 乱用 `ingest-by` タグは推奨されません。
Kusto を供給するパイプラインにデータ重複があることがわかっている場合は、データを Kusto に取り込みする前に、可能な限りこれらの重複を解決することをお勧めします。 また、kusto に `ingest-by` 取り込みするパーツで重複が発生する可能性がある場合にのみ、Kusto にタグを使用します (たとえば、既に進行中のインジェスト呼び出しと重複する再試行メカニズムがあります)。 インジェスト呼び出しごとに一意のタグを設定しようとすると `ingest-by` 、パフォーマンスに重大な影響が生じる可能性があります。
* データの取り込まれた後に一定の期間、このようなタグが不要な場合は、 [エクステントタグを削除](drop-extent-tags.md)することをお勧めします。
